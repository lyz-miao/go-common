package sqlm

import (
	"database/sql"
	"errors"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"time"
)

var (
    ErrNoRows = sql.ErrNoRows
    ErrTxDone = sql.ErrTxDone
)

// A Result summarizes an executed SQL command.
type Result interface {
    // LastInsertId returns the integer generated by the database
    // in response to a command. Typically this will be from an
    // "auto increment" column when inserting a new row. Not all
    // databases support this feature, and the syntax of such
    // statements varies.
    LastInsertId() (int64, error)

    // RowsAffected returns the number of rows affected by an
    // update, insert, or delete. Not every database or database
    // driver may support this.
    RowsAffected() (int64, error)
}

type Config struct {
	DSN             string
	MaxOpenConn     int
	MaxIdleConn     int
	ConnMaxLifetime time.Duration
}

func mergeConfig(c *Config) {
	if c == nil {
		panic(errors.New("Config is nil\n"))
	}

	if c.MaxOpenConn == 0 {
		c.MaxOpenConn = 200
	}
	if c.MaxIdleConn == 0 {
		c.MaxIdleConn = 10
	}
	if c.ConnMaxLifetime == 0 {
		c.ConnMaxLifetime = time.Minute * 5
	}
}

func New(c *Config) *DB {
	mergeConfig(c)

	db, err := sql.Open("mysql", c.DSN)
	if err != nil {
		panic(err)
	}

	db.SetMaxOpenConns(c.MaxOpenConn)
	db.SetMaxIdleConns(c.MaxIdleConn)
	db.SetConnMaxLifetime(c.ConnMaxLifetime)

	if err = db.Ping(); err != nil {
		panic(err)
	}

	return &DB{db}
}

func genInsertParam(table string, fields []string, values [][]interface{}) (string, []interface{}) {
	s := fmt.Sprintf("INSERT INTO `%s` ", table)

	fieldStr := ""
	for i, field := range fields {
		if i == 0 {
			fieldStr += fmt.Sprintf("`%s`", field)
		} else {
			fieldStr += fmt.Sprintf(",`%s`", field)
		}
	}
	s += fmt.Sprintf("(%s) ", fieldStr)

	value := ""
	if len(values) > 0 {
		if len(values) > 1 {
			value += "VALUES "
		} else {
			value += "VALUE "
		}
	}
	s += value

	placeholder := ""
	vs := make([]interface{}, 0)
	for i, v := range values {
		p := ""
		for a, m := range v {
			if a == 0 {
				p += "?"
			} else {
				p += ",?"
			}
			vs = append(vs, m)
		}

		if i == 0 {
			p = fmt.Sprintf("(%s)", p)
		} else {
			p = fmt.Sprintf(",(%s)", p)
		}
		placeholder += p
	}
	s += placeholder

	return s, vs
}
